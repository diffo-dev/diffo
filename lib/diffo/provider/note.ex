defmodule Diffo.Provider.Note do
  @moduledoc """
  Diffo - TMF Service and Resource Management with a difference
  Copyright Matt Beanland beanland@live.com.au

  Note - Ash Resource for a TMF Note
  """
  use Ash.Resource, otp_app: :diffo, domain: Diffo.Provider, data_layer: AshPostgres.DataLayer, extensions: [AshOutstanding.Resource, AshJason.Resource]

  postgres do
    table "notes"
    repo Diffo.Repo
  end

  outstanding do
    expect [:text, :note_id, :author_id]
  end

  jason do
    pick [:text, :note_id, :author_id]
    rename note_id: :id, author_id: :author, timestamp: :date
    customize fn result, record ->
      result
      |> Diffo.Util.suppress(:id)
      |> Diffo.Util.suppress(:author)
      |> Diffo.Util.set(:date, Diffo.Util.to_iso8601(record.timestamp))
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      description "creates a note"
      accept [:instance_id, :text, :note_id, :author_id]
      change set_attribute :timestamp, &DateTime.utc_now/0
      touches_resources [Diffo.Provider.Instance, Diffo.Provider.Party]
    end

    read :find_by_note_id do
      description "finds notes by id"
      get? false
      argument :query, :ci_string do
        description "Return only notes with id's including the given value."
      end
      filter expr(contains(note_id, ^arg(:query)))
    end

    read :list do
      description "lists all notes"
    end

    read :list_notes_by_instance_id do
      description "lists notes by instance id"
      argument :instance_id, :uuid
      filter expr((instance_id == ^arg(:instance_id)))
    end

    read :list_notes_by_author_id do
      description "lists notes by author id"
      argument :author_id, :string
      filter expr((author_id == ^arg(:author_id)))
    end

    update :update do
      description "updates the note, touching the timestamp"
      accept [:instance_id, :text, :note_id, :author_id]
      change set_attribute :timestamp, &DateTime.utc_now/0
    end
  end

  attributes do
    uuid_primary_key :id do
      description "a uuid4, unique to this note, generated by default"
      public? false
    end

    attribute :text, :string do
      description "the text of this note, this is a mandatory value"
      allow_nil? false
      public? true
    end

    attribute :note_id, :string do
      description "the id of the note, this is an optional value"
      allow_nil? true
      public? true
    end

    attribute :timestamp, :utc_datetime_usec do
      description "the timestamp of this note, timestamp is create or last update"
      allow_nil? false
    end
  end

  identities do
    identity :instance_text_uniqueness, [:instance_id, :note_id, :text] do
      eager_check? true
      message "a duplicate note exists"
      nils_distinct? false
    end

    identity :instance_note_id_uniqueness, [:instance_id, :note_id] do
      eager_check? true
      message "another note exists on the instance with same note id"
    end
  end

  relationships do
    belongs_to :instance, Diffo.Provider.Instance do
      description "the related instance"
      allow_nil? false
      public? true
    end

    belongs_to :author, Diffo.Provider.Party do
      description "the optional author of the note on the instance"
      attribute_type :string
      allow_nil? true
      public? true
    end
  end

  preparations do
    prepare build(load: [:author_id], sort: [timestamp: :desc])
  end

  @doc """
  Compares two note, by most recent insertion order
  ## Examples
    iex> Diffo.Provider.Note.compare(%{timestamp: "a"}, %{timestamp: "a"})
    :eq
    iex> Diffo.Provider.Note.compare(%{timestamp: "b"}, %{timestamp: "a"})
    :gt
    iex> Diffo.Provider.Note.compare(%{timestamp: "a"}, %{timestamp: "b"})
    :lt

  """
  def compare(%{timestamp: timestamp0}, %{timestamp: timestamp1}), do: Diffo.Util.compare(timestamp0, timestamp1)
end
