defmodule Diffo.Provider.PlaceRef do
  @moduledoc """
  Diffo - TMF Service and Resource Management with a difference
  Copyright Matt Beanland beanland@live.com.au

  PlaceRef - Ash Resource for a TMF PlaceRef
  """
  use Ash.Resource,
    otp_app: :diffo,
    domain: Diffo.Provider,
    data_layer: AshNeo4j.DataLayer,
    extensions: [AshOutstanding.Resource, AshJason.Resource]

  neo4j do
    relate([
      {:instance, :LOCATES, :incoming, :Instance},
      {:place, :LOCATES, :outgoing, :Place}
    ])
  end

  jason do
    pick([:role, :place])

    customize(fn result, _record ->
      result
      |> Diffo.Util.extract_suppress(:place, :id, :id)
      |> Diffo.Util.extract_suppress(:place, :href, :href)
      |> Diffo.Util.extract_suppress(:place, :name, :name)
      |> Diffo.Util.extract_suppress(:place, :referredType, "@referredType")
      |> Diffo.Util.extract_suppress(:place, :type, "@type")
      |> Diffo.Util.remove(:place)
    end)

    order([:id, :href, :name, :role, "@referredType", "@type"])
  end

  outstanding do
    expect([:role, :place])
  end

  attributes do
    uuid_primary_key :id do
      description "a uuid4, unique to this place ref, generated by default"
      public? false
    end

    attribute :role, :atom do
      description "the role of the place to the instance"
      allow_nil? true
      public? true
    end

    create_timestamp :inserted_at

    update_timestamp :updated_at
  end

  relationships do
    belongs_to :instance, Diffo.Provider.Instance do
      description "the instance which relates to a place via this place ref"
      allow_nil? false
      public? true
    end

    belongs_to :place, Diffo.Provider.Place do
      description "the place which is related from an instance via this place ref"
      attribute_type :string
      allow_nil? false
      public? true
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      description "creates a place ref, relating an instance and a place"
      accept [:role]
      argument :instance_id, :uuid
      argument :place_id, :string

      change manage_relationship(:instance_id, :instance, type: :append_and_remove)
      change manage_relationship(:place_id, :place, type: :append_and_remove)
    end

    read :list do
      description "lists all place refs"
    end

    read :list_place_refs_by_instance_id do
      description "lists place refs by instance id"
      argument :instance_id, :uuid
      filter expr(instance_id == ^arg(:instance_id))
    end

    read :list_place_refs_by_place_id do
      description "lists place refs by place id"
      argument :place_id, :string
      filter expr(place_id == ^arg(:place_id))
    end

    update :update do
      description "updates the place ref role"
      accept [:role]
    end
  end

  identities do
    identity :instance_place_uniqueness, [:instance_id, :place_id] do
      message "another place ref exists relating the same instance and place"
    end
  end

  preparations do
    prepare build(
              load: [:place],
              sort: [role: :asc, inserted_at: :desc]
            )
  end

  @doc """
  Compares two place ref, by ascending place_id
  ## Examples
    iex> Diffo.Provider.PlaceRef.compare(%{place_id: "a"}, %{place_id: "a"})
    :eq
    iex> Diffo.Provider.PlaceRef.compare(%{place_id: "b"}, %{place_id: "a"})
    :gt
    iex> Diffo.Provider.PlaceRef.compare(%{place_id: "a"}, %{place_id: "b"})
    :lt

  """
  def compare(%{place_id: place_id0}, %{place_id: place_id1}),
    do: Diffo.Util.compare(place_id0, place_id1)
end
