defmodule Diffo.Provider.EntityRef do
  @moduledoc """
  Diffo - TMF Service and Resource Management with a difference
  Copyright Matt Beanland beanland@live.com.au

  EntityRef - Ash Resource for a TMF EntityRef
  """
  use Ash.Resource,
    otp_app: :diffo,
    domain: Diffo.Provider,
    data_layer: AshNeo4j.DataLayer,
    extensions: [AshOutstanding.Resource, AshJason.Resource]

  neo4j do
    label(:EntityRef)

    relate([
      {:instance, :RELATES_HOW, :incoming},
      {:entity, :RELATED_HOW, :outgoing}
    ])

    translate(id: :uuid)
  end

  jason do
    pick([:entity_id, :href, :name, :role, :referredType, :type])
    rename(entity_id: :id, referredType: "@referredType", type: "@type")
  end

  outstanding do
    expect([:entity_id, :href, :name, :role, :referredType, :type])
  end

  attributes do
    uuid_primary_key :id do
      description "a uuid4, unique to this entity ref, generated by default"
      public? false
    end

    attribute :role, :atom do
      description "the role of the entity to the instance"
      allow_nil? true
      public? true
    end

    create_timestamp :inserted_at

    update_timestamp :updated_at
  end

  relationships do
    belongs_to :instance, Diffo.Provider.Instance do
      allow_nil? false
      public? true
    end

    belongs_to :entity, Diffo.Provider.Entity do
      attribute_type :string
      allow_nil? false
      public? true
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      description "creates a entity ref, relating an instance and entity"
      accept [:role]
      argument :instance_id, :uuid
      argument :entity_id, :string

      change manage_relationship(:instance_id, :instance, type: :append_and_remove)
      change manage_relationship(:entity_id, :entity, type: :append_and_remove)
      change load [:href, :name, :referredType, :type]
    end

    read :list do
      description "lists all entity refs"
    end

    read :list_entity_refs_by_instance_id do
      description "lists entity refs by instance id"
      argument :instance_id, :uuid
      filter expr(instance_id == ^arg(:instance_id))
    end

    read :list_entity_refs_by_entity_id do
      description "lists entity refs by entity id"
      argument :entity_id, :string
      filter expr(entity_id == ^arg(:entity_id))
    end

    update :update do
      description "updates the entity ref role"
      accept [:role]
    end
  end

  identities do
    identity :instance_entity_uniqueness, [:instance_id, :entity_id] do
      message "another entity ref exists"
    end
  end

  preparations do
    prepare build(load: [:href, :name, :referredType, :type], sort: [inserted_at: :desc])
  end

  calculations do
    calculate :href, :string, expr(entity.href) do
      description "the href of the related entity instance"
    end

    calculate :name, :string, expr(entity.name) do
      description "the name of the related entity instance"
    end

    calculate :referredType, :atom, expr(entity.referredType) do
      description "the referredType of the related entity instance"
    end

    calculate :type, :atom, expr(entity.type) do
      description "the type of the related entity instance"
    end
  end

  @doc """
  Compares two entity ref, by ascending entity_id
  ## Examples
    iex> Diffo.Provider.EntityRef.compare(%{entity_id: "a"}, %{entity_id: "a"})
    :eq
    iex> Diffo.Provider.EntityRef.compare(%{entity_id: "b"}, %{entity_id: "a"})
    :gt
    iex> Diffo.Provider.EntityRef.compare(%{entity_id: "a"}, %{entity_id: "b"})
    :lt

  """
  def compare(%{entity_id: entity_id0}, %{entity_id: entity_id1}),
    do: Diffo.Util.compare(entity_id0, entity_id1)
end
