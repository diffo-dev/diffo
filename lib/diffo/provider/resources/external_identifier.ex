defmodule Diffo.Provider.ExternalIdentifier do
  @moduledoc """
  Diffo - TMF Service and Resource Management with a difference
  Copyright Matt Beanland beanland@live.com.au

  ExternalIdentifier - Ash Resource for a TMF ExternalIdentifier
  """
  use Ash.Resource,
    otp_app: :diffo,
    domain: Diffo.Provider,
    data_layer: AshNeo4j.DataLayer,
    extensions: [AshOutstanding.Resource, AshJason.Resource]

  neo4j do
    label(:ExternalIdentifier)
    relate([
      {:instance, :REFERENCES, :incoming},
      {:owner, :OWNS, :incoming}
    ])
    translate(id: :uuid)
  end

  jason do
    pick([:type, :external_id, :owner_id])
    rename(type: :externalIdentifierType, external_id: :id, owner_id: :owner)

    customize(fn result, _record ->
      result
      |> Diffo.Util.suppress(:id)
      |> Diffo.Util.suppress(:owner)
    end)
  end

  outstanding do
    expect([:type, :external_id, :owner_id])
  end

  attributes do
    uuid_primary_key :id do
      description "a uuid4, unique to this external identifier, generated by default"
      public? false
    end

    attribute :type, :string do
      description "the type of this external identifier, this is an optional value"
      allow_nil? true
      public? true
    end

    attribute :external_id, :string do
      description "the id of the external identifier, this is an optional value"
      allow_nil? true
      public? true
    end

    create_timestamp :inserted_at

    update_timestamp :updated_at
  end

  relationships do
    belongs_to :instance, Diffo.Provider.Instance do
      description "the related instance"
      allow_nil? false
      public? true
    end

    belongs_to :owner, Diffo.Provider.Party do
      description "the optional owner of the external identifier on the instance"
      attribute_type :string
      allow_nil? true
      public? true
    end
  end

  actions do
    defaults [:read, :destroy]

    create :create do
      description "creates a external identifier"
      accept [:type, :external_id, :owner_id, :instance_id]
      change load [:owner_id]
      touches_resources [Diffo.Provider.Instance, Diffo.Provider.Party]
    end

    read :find_by_external_id do
      description "finds external identifiers by id"
      get? false

      argument :query, :ci_string do
        description "Return only external identifiers with id's including the given value."
      end

      filter expr(contains(external_id, ^arg(:query)))
    end

    read :list do
      description "lists all external identifiers"
    end

    read :list_external_identifiers_by_instance_id do
      description "lists external identifiers by instance id"
      argument :instance_id, :uuid
      filter expr(instance_id == ^arg(:instance_id))
    end

    read :list_external_identifiers_by_owner_id do
      description "lists external identifiers by owner id"
      argument :owner_id, :string
      filter expr(owner_id == ^arg(:owner_id))
    end

    update :update do
      description "updates the external identifier"
      accept [:type, :external_id, :owner_id, :instance_id]
    end
  end

  identities do
    identity :instance_type_uniqueness, [:instance_id, :type] do
      message "another external identifier exists on the instance with same type"
    end
  end

  preparations do
    prepare build(load: [:owner_id], sort: [inserted_at: :desc])
  end

  validations do
    validate present([:type, :external_id, :owner_id], at_least: 1) do
      message "at least one of type, external id an owner id must exist"
    end
  end

  @doc """
  Compares two external identifier, by most recent insertion order
  ## Examples
    iex> Diffo.Provider.ExternalIdentifier.compare(%{inserted_at: "a"}, %{inserted_at: "a"})
    :eq
    iex> Diffo.Provider.ExternalIdentifier.compare(%{inserted_at: "b"}, %{inserted_at: "a"})
    :gt
    iex> Diffo.Provider.ExternalIdentifier.compare(%{inserted_at: "a"}, %{inserted_at: "b"})
    :lt

  """
  def compare(%{inserted_at: inserted_at0}, %{inserted_at: inserted_at1}),
    do: Diffo.Util.compare(inserted_at0, inserted_at1)
end
